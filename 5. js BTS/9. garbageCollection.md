ğŸ¯ Garbage Collection in JavaScript

### What is Garbage Collection?
- Automatic memory management in JavaScript.
- Frees up memory for objects that are no longer needed.

### How Does It Work?
1. **Mark-and-Sweep Algorithm**:
   - **Mark**: Identify all reachable objects from roots (global variables, call stack, event listeners, closures).
   - **Sweep**: Delete unreachable objects and reclaim memory.

### Key Concepts:
- **Reachable Objects**: Objects with active references.
- **Unreachable Objects**: Objects with no active references.
- **Roots**: Starting points for identifying reachable objects (global variables, call stack, event listeners, closures).

### Example:
```javascript
// Step 1: Define functions and variables
function getTasks() {
    const tasks = ["Learn JavaScript", "Complete project"];
    return tasks;
}

function calcAge(birthYear) {
    const y = "Jonas";
    const z = true;
    return 2037 - birthYear;
}

const x = 234;
const hobbies = ["playing", "studying", "cycling"];

// Step 2: Call functions and use variables
console.log(getTasks()); // ["Learn JavaScript", "Complete project"]
console.log(calcAge(1991)); // 46

// Step 3: Delete the `calcAge` function
delete calcAge;

// Step 4: Try to call `calcAge` again
console.log(calcAge); // undefined (function is no longer accessible)
```

Initial State, Before deleting the calcAge function;

#initial state
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ CALL STACK    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Global EC     â”‚
â”‚   x           â”‚
â”‚   hobbies     â”‚
â”‚   getTasks()  â”‚
â”‚   calcAge()   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ HEAP          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ tasks         â”‚
â”‚ y             â”‚
â”‚ z             â”‚
â”‚ hobbies array â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Roots:
- Global variables (`x`, `hobbies`)
- Call stack (Execution Contexts for `getTasks()` and `calcAge()`)
- Event listeners (not +nt in this example)
- Closures (not +nt in this example)

**Step 1: Mark-and-Sweep Before Deletion**
Mark Phase : 

    Global EC :
        x â†’ Marks x as alive.
        hobbies â†’ Marks hobbies array as alive.
        getTasks() â†’ Marks getTasks() as alive.
        calcAge() â†’ Marks calcAge() as alive.
         
    Call Stack :
        getTasks() EC:
            tasks â†’ Marks tasks array as alive.
             
        calcAge() EC:
            y â†’ Marks y string as alive.
            z â†’ Marks z boolean as alive.
             
         
     

Sweep Phase : 

    All objects are reachable, so nothing is deleted yet.

**Step 2: Delete the calcAge Function/after getting out of any function**
When you run delete calcAge;, the global reference  to the calcAge function is removed. However, the actual function object in the Heap  is still there because itâ€™s part of the Call Stack  (since calcAge was called earlier).

#updated state  
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ CALL STACK    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Global EC     â”‚
â”‚   x           â”‚
â”‚   hobbies     â”‚
â”‚   getTasks()  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ HEAP          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ tasks         â”‚
â”‚ y             â”‚
â”‚ z             â”‚
â”‚ hobbies array â”‚
â”‚ calcAge func  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Roots:
- Global variables (`x`, `hobbies`)
- Call stack (Execution Contexts for `getTasks()` and `calcAge()`)
- Event listeners (none in this example)
- Closures (none in this example)

**Step 3: Garbage Collection After Deletion**  
Mark Phase : 

    Global EC :
        x â†’ Marks x as alive.
        hobbies â†’ Marks hobbies array as alive.
        getTasks() â†’ Marks getTasks() as alive.
        calcAge() â†’ Not marked (no global reference).
         
    Call Stack :
        getTasks() EC:
            tasks â†’ Marks tasks array as alive.
             
        calcAge() EC:
            y â†’ Marks y string as alive.
            z â†’ Marks z boolean as alive.
             
         
     

Sweep Phase : 

    The calcAge function and its associated variables (y, z) are now unreachable .
    They are deleted from the Heap , and their memory is reclaimed.

#final state  
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ CALL STACK    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Global EC     â”‚
â”‚   x           â”‚
â”‚   hobbies     â”‚
â”‚   getTasks()  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ HEAP          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ tasks         â”‚
â”‚ hobbies array â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Roots:
- Global variables (`x`, `hobbies`)
- Call stack (Execution Contexts for `getTasks()`)
- Event listeners (none in this example)
- Closures (none in this example)

**xTra IMP**
always, we don't need to delete any function or object , just when we'll end using an function/object 
or when we'll get out of a function , then our connection will be unreachable to that function +nt in HEAP,  at that moment it will also be removed automatically by garbage collector of js