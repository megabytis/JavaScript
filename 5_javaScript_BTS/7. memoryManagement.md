ðŸŽ¯ The Memory Lifecycle in JavaScript

1. **Allocate Memory** :
   - Automatically reserves memory when a variable is declared and assigned a value.
   - Example:
   ```javascript
   let temp = 23.7; // Memory is allocated for `temp`
   ```

2. **Use Memory** : 

    - Values are read, written, and updated while the code is running.
    - Example:
    ``` js
    temp = temp + 5; // Value is updated in memory
    round(temp);     // Value is read from memory
    ```

3. **Release Memory** : 

    - Unused memory is freed up by the garbage collector when values are no longer needed.
    - Example:
    ``` js
    let y = 10; // Memory is allocated for `y`
    // `y` goes out of scope
    // Garbage collector will release memory for `y`
    ```

--> so, js does all automatically, we don't need to worry .


ðŸŽ¯ Where Is Memory Allocated in JavaScript?

1. **Call Stack**:
   - **Stores**: Primitives (e.g., `Number`, `String`, `Boolean`) and  object references.
   - **Why**: Primitives are small and fixed-size, so theyâ€™re stored directly in the Call Stack for fast access.

2. **Heap**:
   - **Stores**: Complex data structures (e.g., objects, arrays, functions).
   - **Why**: Objects can be large and dynamic, so theyâ€™re stored in the Heap. The Call Stack holds references to these objects.

### Example:
```javascript
let x = 42; // Stored in Call Stack
let obj = { name: "Jonas" }; // Stored in Heap, with a reference in Call Stack
```

- Primitives  (String, Number, etc.) are stored directly in the Call Stack i.e. variables.
- Objects  (e.g., Object literals, Arrays, Functions) are stored in the Heap , and the Call Stack  holds references(i.e. pointer address) of them.

e.g.
``` js
const name = 'Jonas';
const age = calcAge(1991);
let newAge = age;
newAge++;

const location = {
  city: 'Faro',
  country: 'Portugal',
};

const newLocation = location; // Reference copying
newLocation.city = 'Lisbon'; // Modifies the original object

console.log(location); // { city: 'Lisbon', country: 'Portugal' }

function calcAge(birthYear) {
  const now = 2037;
  const age = now - birthYear;
  return age;
}
```
###### above code's BACKEND :----------------

inside **Heap**:

elements of const location
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  
â”‚ city: 'Faro'âŒ        â”‚
â”‚       'Lisbon'âœ…      â”‚
â”‚ country: 'Portugal'   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

function calcAge
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  
â”‚  function calcAge(birthYear) {   â”‚
â”‚     const now = 2037;            â”‚
â”‚     const age = now - birthYear; â”‚
â”‚     return age;                  â”‚
â”‚  }                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

inside **Call Stack**:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Global Execution Contextâ”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ name: 'Jonas'           â”‚
â”‚ age: 46                 â”‚
â”‚ newAge: 46 âŒ           â”‚
â”‚         47 âœ…           â”‚
â”‚ location: REFERENCE     â”‚
â”‚ newLocation: REFERENCE  â”‚
â”‚ calcAge: REFERENCE      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
REFERENCE (i.e. pointer address of those objects / functions present in the Heap)
-> so whatever we'll change in location/newLocation/calcAge elements, it will directly change in heap through reference +nt in stack
